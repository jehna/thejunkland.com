<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><style>body>*,header span,img{margin:0 auto}@font-face{font-family:Oswald;font-style:normal;font-weight:400;src:local("Oswald Regular"),local("Oswald-Regular"),url(/oswald.woff) format("woff")}h1,h2,h3,h4,h5,h6,header{font-family:Oswald,sans-serif;padding-top:38px;color:#3b447c;line-height:1.2em;text-align:center}img{max-width:100%;height:auto;display:block}h1{opacity:.8;font-size:1.6em}body,html{margin:0;padding:0}body{font:19px Georgia,serif;color:#333;-webkit-font-smoothing:antialiased}body>*{max-width:740px;box-sizing:border-box;padding-left:19px;padding-right:19px}p{line-height:1.4em;padding-top:1em;margin-top:0;margin-bottom:0}article p:first-child{font-size:1.4em;line-height:1.4em;padding-bottom:.2em}header{background:#6672B7;color:#FFF;padding:1.6em .4em;font-size:2.4em;line-height:1.2em;text-align:center;max-width:100%;font-weight:400}header span{max-width:640px;display:block;text-shadow:0 3px 0 rgba(0,0,0,.2)}header small{display:block;font-size:.43em;font-family:Georgia,serif;text-shadow:0 2px 0 rgba(0,0,0,.2)}header img{border-radius:50%;vertical-align:middle;width:40px;height:40px}code,pre{overflow-x:auto;max-width:100%}a{color:#6672B7}a:visited{color:tint(#6672B7,20%)}section nav{font-size:1.4em;line-height:1.4em}</style><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico"><title>Let's build a frontend library — Part 1: Templating</title><link rel="manifest" href="/manifest.webmanifest"></head><body class="draft"><header><span>Let's build a frontend library — Part 1: Templating</span> <small>A blog post by Jesse Luoto</small></header><main><article><p>Different tools make different trade-offs about building user interfaces. What if we looked into modern approaches and combined the best into one single library?</p><h1 id="for-the-reader">For the reader</h1><p>This blog post is the author&#39;s opinionated view on what different approaches do well and what they don&#39;t.</p><p>This is intended to be a living document hosted at the <a href="https://github.com/jehna/thejunkland.com/tree/master/content/blog/lets-build-a-frontend-library-part-1">Github repository</a>. All feedback is welcomed, please use the Twitter handle <a href="https://twitter.com/luotojesse">@luotojesse</a> to let me know what you think or open an issue/pull request directly to the repository.</p><h1 id="framework-vs-library">Framework vs library</h1><p>Let&#39;s start by defining a bit of the scope; why didn&#39;t I title this blog post as &quot;Let&#39;s build a frontend <em>framework</em>&quot;?</p><p>Framework implies that it&#39;s an opinionated way of building software. Most frameworks give you basic components that you&#39;ll learn and then use those building blocks to create whatever it is you&#39;re doing.</p><p>It&#39;s great that a framework has an answer to all common problems — you probably need a bunch of stuff like templating, routing and HTTP requests from the get-go, so why should you waste your time figuring out these common building blocks every time you start a new project?</p><p>The flip side of the coin is that using a framework usually forces you to accept everything it offers, so you&#39;re taking a huge bet to get everything right on one first try.</p><p>Take React and Angular as an example. With React you&#39;re free to use any routing library you please — in the end it&#39;s <em>just a view library</em>. But with Angular you&#39;ll probably end up using Angular&#39;s own routing, and that probably covers 80% of use cases very well, and additional 10% of use cases moderately.</p><p>But how about that last 10%? Sometimes you find yourself fighting against the framework. We&#39;ve all been there. The framework&#39;s assumptions just don&#39;t match the domain of your problem. It might be awkward or even impossible to do what you want.</p><p>The worst thing is, that this eventually happens with all projects, sooner or later. And I&#39;d rather swap a single library than rewrite the whole app with another framework.</p><h1 id="templating-language-vs-host-language">Templating language vs. host language</h1><p>A website, static or not, is essentially structured with HTML and styled with CSS. While you could type out all needed HTML and CSS in a single file and upload it to a static website host, you probably have some recurring elements on your page that you&#39;d like to reuse. This brings us to templating.</p><p>The naive way of doing templating would be to split reusable parts of the website to their own HTML files and create a simple way of parsing those files together.</p><p>As an example, here&#39;s how you could implement a basic website using a simple template:</p><pre><code><span class="hljs-section">&lt;my-header /&gt;</span>
<span class="hljs-section">&lt;p&gt;</span>
  <span class="hljs-attribute">Hello</span> world!
<span class="hljs-section">&lt;/p&gt;</span>
<span class="hljs-section">&lt;my-footer /&gt;</span>
</code></pre><p>Using this template you could replace <code>&lt;my-header /&gt;</code> and <code>&lt;my-footer /&gt;</code> with the shared HTML from some other template file. This way you&#39;d avoid making changes to multiple places when something needs to be changed. Simple enough, right?</p><p>But here&#39;s where things get complicated: You probably need to do loops and conditionals at some point of your template. Now how do you handle that?</p><p>The naive way would be to go extend our templating language — much like how e.g. Angular, Vue, Svelte and Polymer have done it. You introduce new tags like <code>&lt;if&gt;</code> and <code>&lt;foreach&gt;</code> that accept arguments as attributes, and you keep extending your naive templating language until most cases are possible.</p><p>But there&#39;s another way that&#39;s being used by e.g. React, SwiftUI and Flutter: They use the host language for this stuff. If you think about it, why on earth would you start crafting your own competing language when you already have an established, turing-complete language at your disposal? Javascript, Dart and Swift all have their own implementations of loops, conditionals and variables.</p><p>For example with SwiftUI you&#39;d do conditionals in your templates just as you&#39;d do them outside of your templates:</p><pre><code class="lang-swift"><span class="hljs-keyword">if</span> someConditionIsTrue {
  <span class="hljs-type">TabView</span>()
} <span class="hljs-keyword">else</span> {
  <span class="hljs-type">LoginView</span>()
}
</code></pre><h2 id="jsx-vs-plain-functions">JSX vs. plain functions</h2><p>You can use React without JSX, and you&#39;ll end up with a monstrosity called <code>React.createElement(type, [props], [...children])</code>. While you certainly <em>could</em> use this API, you don&#39;t see it used that much over JSX. Why? The developer experience is just unacceptable.</p><p>You&#39;ll end up repeating the useless <code>React.createElement</code> chant over and over again, and the lack of named variables and either-pass-in-function-or-a-string API are just confusing.</p><p>And again: Why would you create <strong>a new language</strong> (jsx) just because you have a verbose API? Why are developers so keen on creating new languages?</p><p>Fortunately there&#39;s a better way that does not involve creating a new programming language, and that&#39;s called <em>renaming</em>.</p><p>Yep, both Flutter and SwiftUI essentially use the language&#39;s own structures for representing the element hierarchy and it doesn&#39;t feel awkward at all.</p><p>Here&#39;s an example component hierarchy from Flutter:</p><pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) {
    <span class="hljs-keyword">return</span> <span class="hljs-type">Container</span>(
      child: <span class="hljs-type">Center</span>(
        child: <span class="hljs-type">Text</span>(
          <span class="hljs-symbol">&#x27;Hello</span> <span class="hljs-type">World</span>&#x27;,
          textDirection: <span class="hljs-type">TextDirection</span>.ltr,
          style: <span class="hljs-type">TextStyle</span>(
            fontSize: <span class="hljs-number">32</span>,
            color: <span class="hljs-type">Colors</span>.black87,
          ),
        ),
      ),
    );
  }
}
</code></pre><p>There&#39;s no clutter compared to using <code>React.createElement</code>, and you have the same verbosity as with JSX, only the open and close characters switch places from <code>&lt;Component&gt;</code> to <code>Component()</code>.</p><h2 id="function-components-vs-oop-components">Function Components vs. OOP Components</h2><p>Each frontend library and framework have their own way of describing components. Tools that don&#39;t use a templating language have two primary approaches that I&#39;m going to compare: OOP Components (e.g. Angular, <code>React.Component</code> and Flutter) and React&#39;s Function Components.</p><p>Class components are a naive solution to holding state, but we&#39;ll cover state handling later. If we only look at constructing DOM hierarchies (basically stitching HTML together), I&#39;d argue there&#39;s no need to use an OOP Component.</p><p>The beauty of having a Function Components is that you provide one input that always returns the same output (not accounting for the React&#39;s <code>useState</code> hook monstrosity). Some more academic people refer to this as seeing UI as the function of the state.</p><p>Using classes introduces all the shortcomings of object oriented programming. You&#39;re faced with the inheritance vs. composition question which is ruled as &quot;just don&#39;t do that&quot; at the React community. Testing becomes harder when you have to use more effort to set the world into a certain state. And in practice I&#39;ve seen and experienced more friction in splitting OOP Components into smaller ones than with Function Components.</p><h1 id="virtual-dom-or-the-real-one-">Virtual DOM or the real one?</h1><p>Creating and destroying DOM is slow. Or at least that&#39;s what we have been told. But slow compared to <em>what</em>? Svelte doesn&#39;t use virtual DOM and it claims to be faster than any framework implementing virtual dom. So what&#39;s going on here?</p><h1 id="apples-and-oranges">Apples and oranges</h1><p>React brought the concept of virtual DOM to the wide audience, and it was deemed as &quot;the fast way of doing DOM&quot;. But the baseline was very skewed; they always compared the speed of virtual DOM to creating <strong>and removing</strong> dom nodes every time the state changes.</p><p>This means that the baseline was so <code>React.createElememt</code> would always create the full DOM element every time something changed, and that they would throw all existing DOM out of the window. You can see why this was probably quite a slow approach.</p><p>Virtual DOM is indeed the naive solution for this problem: Instead of creating the real DOM elements, let&#39;s create a minimal intermediate representation of a DOM element instead. It&#39;s still relatively slow to create huge trees of plain JS objects and diff them to find out the minimal changeset, but at least it&#39;s less work than the baseline.</p><p>Of course there are more advanced optimizations to this approach like <code>shouldComponentUpdate</code>, <code>React.memo</code>, React Fibers and better diffing algorithms, but essentially you&#39;re still doing a lot of extra work to calculate the actual changeset.</p><p>Svelte beats most benchmarks compared to virtual DOM, because it calculates the needed changes without using an intermediate object hierarchy. Svelte uses clever tricks to generate some intermediate code at compile time that stitches and pokes DOM when something changes.</p><p>But why on earth does it need <strong>a new programming language</strong> for doing that? What&#39;s the matter with developers nowadays? And yes, Svelte is very much a new programming language although it tries to hide it at the marketing material. It has its own syntax for reactive statements and it implements a custom templating language.</p><p>But why does it need a new programming language to do this? Couldn&#39;t we have that intermediate dom-handling code as a library and achieve the same end result — fast apps without virtual DOM?</p><h2 id="minimal-changes-from-the-library">Minimal changes from the library</h2><p>Let&#39;s say we would implement a library that only creates DOM nodes declaratively. How would it look like? The most naive way would require that we know where we&#39;d mount and what to mount. Something like:</p><pre><code class="lang-typescript"><span class="hljs-keyword">type</span> Component = <span class="hljs-function">(<span class="hljs-params">props: <span class="hljs-built_in">any</span>, parent: Node</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
</code></pre><p>This way we could do a simple <code>div</code> component something like so:</p><pre><code class="lang-typescript"><span class="hljs-keyword">const</span> div: Component = <span class="hljs-function">(<span class="hljs-params">props, parent</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>); <span class="hljs-comment">// Create element</span>
  <span class="hljs-built_in">Object</span>.entries(props).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> ((el <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key] = value)); <span class="hljs-comment">// Set props</span>
  parent.appendChild(el); <span class="hljs-comment">// Mount element</span>
};
</code></pre><p>This way we could mount a simple <code>&lt;div&gt;</code> element with the following code:</p><pre><code class="lang-typescript">div({ innerText: <span class="hljs-string">&quot;Hello world&quot;</span> }, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>)!);
</code></pre><p>Pretty good for a naive approach! But we&#39;ll need a declarative way of creating nested components, so let&#39;s add a special <code>children</code> prop and revisit the component type:</p><pre><code class="lang-typescript"><span class="hljs-keyword">type</span> Component = <span class="hljs-function">(<span class="hljs-params">props: <span class="hljs-built_in">any</span></span>) =&gt;</span> MountFn;
<span class="hljs-keyword">type</span> MountFn = <span class="hljs-function">(<span class="hljs-params">parent: Node</span>) =&gt;</span> <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> div: Component = <span class="hljs-function">(<span class="hljs-params">{ children = [], ...props }</span>) =&gt;</span> (parent) =&gt; {
  <span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>); <span class="hljs-comment">// Create element</span>
  <span class="hljs-built_in">Object</span>.entries(props).forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> ((el <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[key] = value)); <span class="hljs-comment">// Set props</span>
  children.map(<span class="hljs-function">(<span class="hljs-params">child: MountFn</span>) =&gt;</span> child(el)); <span class="hljs-comment">// Mount children</span>
  parent.appendChild(el); <span class="hljs-comment">// Mount element</span>
};
</code></pre><p>After this our declarative app looks like this:</p><pre><code class="lang-typescript"><span class="hljs-keyword">const</span> mount = div({
  children: [
    div({ innerText: <span class="hljs-string">&quot;First line&quot;</span> }),
    div({ innerText: <span class="hljs-string">&quot;Second line&quot;</span> }),
  ],
});
mount(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>)!);
</code></pre><p>You can check out <a href="https://codesandbox.io/s/bold-river-jmytb?file=/src/index.ts">an example project</a> to test out this approach. Note that the example project only implements a few HTML tags and does not take state changes into account. We&#39;ll come back to state later, but the mount function serves as a good starting point for implementing minimal changes when state changes are detected.</p><h1 id="server-side-rendering">Server-side rendering</h1><p>Is server-side rendering still a thing in 2020? I&#39;d argue that it very much is, based on two things:</p><h2 id="1-seo-crawlers">1. SEO / crawlers</h2><p>Yes, there&#39;s a lot of content out there that only renders with Javascript and Google indexes it just fine. But there&#39;s some debate over different kinds of Google crawlers and serving the other search engines, so if you want to be on the safe side, you want to use a server-side rendered site.</p><p>There&#39;s also other kind of crawlers that may be accessing your site like Internet Archive&#39;s Wayback Machine, article readers and bots that are trying to make sense of the world (like GPT-3 is using Common Crawl datasets for training which are sourced by reading good old HTML pages).</p><p>I very much believe that the Internet should be free (as in &quot;free speech&quot;, not as in &quot;free beer&quot;), and server-side rendering of the main content keeps the content easily accessible for everyone.</p><h2 id="what-if-you-don-t-need-a-dynamic-site-">What if you don&#39;t need a dynamic site?</h2><p>Some sites (like this blog) don&#39;t change content, perform calculations or A/B tests, nor load 100s of kilobytes worth of code just to display a static HTML page.</p><p>I have several blogs, and all of them are built either on my own laptop or at a CI server. I love that I can do this and use whatever static hosting to serve the lightweight html files.</p><p>Some CMS providers like Contentful and Netlify have seen this opportunity and provide tools to pre-build the website once the content changes. This creates lightning-fast static websites that are a competitive asset in a world where every fraction of a second saved means more sales.</p><h1 id="what-s-next-">What&#39;s next?</h1><p>We haven&#39;t yet considered the elephan in the room: State management. It&#39;s a big topic worthy of its own blog post, so stay tuned.</p><p><a href="https://twitter.com/intent/tweet?text=%22Let%27s%20build%20a%20frontend%20library%20%u2014%20Part%201%3A%20Templating%22%20by%20@luotojesse%20https://thejunkland.com/blog/lets-build-a-frontend-library-part-1.html" class="twittershare" target="_blank" rel="noopener">Tweet</a></p><form action="https://script.google.com/macros/s/AKfycbxRbnrX_4N2LPp7P2DIYuVA9BqnZeJPKHZaNedhjakItb9Rxm83/exec" method="POST"><h3>Be the first to know from new&nbsp;blog&nbsp;posts</h3><p>Subscribe to the mailing list to get priority access to new blog posts!</p><div><input type="email" name="email" placeholder="Your email address" aria-label="Your email address"></div><button type="submit">Subscribe!</button></form></article></main><footer><p>This site was made with &#9825; by Jesse Luoto.</p><p>Header font is <a href="https://www.google.com/fonts/specimen/Oswald">Oswald Regular</a> from Google Fonts</p><nav><a href="/index.html">Blog</a> <a href="/about.html">About</a></nav></footer><script src="/scripts.bd620f8c.js" async></script></body></html>