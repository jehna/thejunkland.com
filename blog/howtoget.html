<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><style>body>*,header span,img{margin:0 auto}@font-face{font-family:Oswald;font-style:normal;font-weight:400;src:local("Oswald Regular"),local("Oswald-Regular"),url(/oswald.woff) format("woff")}h1,h2,h3,h4,h5,h6,header{font-family:Oswald,sans-serif;padding-top:38px;color:#0d1113;line-height:1.2em;text-align:center}img{max-width:100%;height:auto;display:block}h1{opacity:.8;font-size:1.6em}body,html{margin:0;padding:0}body{font:19px Georgia,serif;color:#333;-webkit-font-smoothing:antialiased}p,section nav{line-height:1.4em}body>*{max-width:740px;box-sizing:border-box;padding-left:19px;padding-right:19px}p{padding-top:1em;margin-top:0;margin-bottom:0}article p:first-child{font-size:1.4em;line-height:1.4em;padding-bottom:.2em}header{background:#7b8ad6;color:#FFF;padding:1.6em .4em;font-size:2.4em;line-height:1.2em;text-align:center;max-width:100%;font-weight:400}header span{max-width:640px;display:block;text-shadow:0 3px 0 rgba(0,0,0,.2)}header small{display:block;font-size:.5em;font-family:Georgia,serif;opacity:.8}header img{border-radius:50%;vertical-align:middle;width:40px;height:40px}code,pre{overflow-x:auto;max-width:100%}a{color:#7b8ad6}a:visited{color:#95a1de}section nav{font-size:1.4em}</style><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico"><title>How to get 100/100 in Google PageSpeed Insights</title></head><body><header><span>How to get 100/100 in Google PageSpeed Insights</span> <small>A blog post by Jesse Luoto</small></header><article><p>You know your website should be fast. But <em>how</em> fast should it be? You know, it really depends how image-heavy the designer made the layout in the first place.</p><p>And what do you compare the website to? Competitors? Ha! Their sites suck even more than yours!</p><p>Building a website that loads outstandingly fast should be the de-facto on the industry (much like using https), but it rather seldom delivers to do so.</p><p>I decided to make this website my first 100/100 website, no matter what it takes. And here&#39;s my journey.</p><h1 id="a-very-different-mindset">A very different mindset</h1><p>As I mentioned before, designers might not be aware of the performance consequences of their work. Therefore it might be impossible for the developer to salvage the outcome when the front page&#39;s images alone take 20MiB to download.</p><p>This is where a <em>performance budget</em> becomes handy. As Tim Kadlec explains in his <a href="https://timkadlec.com/2013/01/setting-a-performance-budget/">blog post about performance</a>, the performance is something that can be designed, agreed on, and purposely delivered to the final product.</p><blockquote><p>Performance should be brought up early and often to emphasize its importance.</p></blockquote><p>Thus we should clearly constraint the negative effects of some visual decisions that can bloat into some serious performance issues later on.</p><h2 id="setting-the-constraints">Setting the constraints</h2><p>Before the designer starts their work, you should decide on the real-life scenario that you want to target. As an example the site should:</p><ul><li>Load in 0.5 seconds with a desktop computer in Paris</li><li>Be usable in 0.5 seconds with a mobile 3G connection from UK</li><li>Load faster than 90% of the competitors</li></ul><p>Deciding on the target early on makes it easy to calculate the exact constraints that your performance budget cannot exceed. In the example above, we could roughly translate the budget as follows:</p><ul><li>Target: 0.5sec for site to be usable in 3G connection</li><li>Looking at <a href="http://media.ofcom.org.uk/news/2014/3g-4g-bb-speeds/">UK average 3G load statistics</a> we can estimate that:<ul><li>Average download speed with 3G in London is <strong>4.1Mbit/s</strong></li><li><strong>80ms</strong> on network latency should be a safe guess</li></ul></li><li><strong>150ms</strong> for the browser parsing and rendering</li><li>That leaves us <strong>350ms</strong> on the actual site download</li><li><strong>Max 3 different file downloads</strong> before first render, each reducing the total downloadable amount via latency</li><li>Absolute max size <strong>0.5Mbit</strong>, including photos</li></ul><p>Agreeing on the performance budget <em>before</em> the design has even started changes the whole mindset; suddenly the performance isn&#39;t anymore only the programmer&#39;s problem, but rather both the programmer and designer work hand-in-hand to deliver the agreed performance.</p><h1 id="a-traditional-approach">A traditional approach</h1><p>Most of the times, like with this website, you unfortunately have some kind of existing site that you have to start improving. So the first thing you do is to fire up the <a href="https://developers.google.com/speed/pagespeed/insights/">Google PageSpeed Insights</a> and see what score you&#39;ll end up with.</p><blockquote><p>Mobile: <em>84/100</em>, Desktop: <em>94/100</em></p></blockquote><p>Hmm, not that bad. Now we know where we&#39;re at, so starting on the technical improvements should be pretty straightforward.</p><p>Since the desktop seems to be &quot;nearly perfect&quot;, we&#39;ll start from there.</p><h2 id="eliminate-render-blocking-javascript-and-css-in-above-the-fold-content">Eliminate render-blocking JavaScript and CSS in above-the-fold content</h2><p>Ok, so the page needs to <em>wait</em> for an unnecessary request before it can be rendered. The flow goes somewhat like this:</p><ol><li>The browser connects to the server and performs low-level networking handshakes to open a connection <em>~50ms</em></li><li>HTML file starts downloading <em>~50ms</em></li><li>The file gets parsed <em>~30ms</em></li><li>Parsing finds a <em>render-blocking</em> css file from <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code></li><li>Rendering is halted until the CSS file gets downloaded</li><li>CSS file connection and download <em>~100m</em></li><li>CSS file parsing and document rendering <em>~10ms</em></li></ol><p>So this extra round-trip to download the CSS file nearly doubles the time needed to render the first image to the user. Therefore it makes sense to actually inline some of the CSS so we can save at least the network latency on the first load.</p><h3 id="inlining-the-css">Inlining the CSS</h3><p>So, let&#39;s inline some of the CSS and copy-paste the lazy load code from Google&#39;s <a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery#example">CSS optimization page</a>:</p><pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cb = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> l = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>); l.rel = <span class="hljs-string">'stylesheet'</span>;
    l.href = <span class="hljs-string">'style.css'</span>;
    <span class="hljs-keyword">var</span> h = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>]; h.parentNode.insertBefore(l, h);
};
<span class="hljs-keyword">var</span> raf = requestAnimationFrame || mozRequestAnimationFrame ||
    webkitRequestAnimationFrame || msRequestAnimationFrame;
<span class="hljs-keyword">if</span> (raf) raf(cb);
<span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, cb);
</code></pre><p>To get the wanted result, we have to inline a subset of the CSS (I inlined the loader part) and lazy-load the rest of the CSS. I used a simple <code>grunt-contrib-replace</code> plugin to do the dirty job. Deploy, fire up PageSpeed and see how we did:</p><blockquote><p>Mobile: <em>79/100</em>, Desktop: <em>92/100</em></p></blockquote><p>Alrighty then... The score actually got worse. A quick inspection on the result revealed that PageSpeed skipped my page loader (I know, I know, loaders are for poor flash sites) and told me the brutal reality:</p><blockquote><p>...your page could [not] be rendered without waiting for the ... resources to load.</p></blockquote><p>So now my loader loaded quickly, but that made the <em>actual</em> content on the site load slower.</p><h3 id="get-rid-of-that-loader">Get rid of that loader</h3><p>Ok, it was bad design anyway. What I did was that I changed my strategy a bit: Inline the main CSS and lazy-load the unnecessary CSS. And get rid of that loader at the start.</p><p>I still needed the loader to <em>exist</em>, since the in-site links used it to smooth out the page loads (and to avoid unnecessary redraws and parsing). But rather than making it the <em>first</em> thing to be loaded, I moved it to be the <em>last</em> thing that would be lazy-loaded within the CSS. The result?</p><blockquote><p>Mobile: <em>98/100</em>, Desktop: <em>98/100</em></p></blockquote><p>That&#39;s what I&#39;m talking about!</p><h2 id="leverage-browser-caching">Leverage browser caching</h2><p>The last thing Google wanted me to do was to set expiration dates for my .css and .js files.</p><p>The bad thing about setting protocol-level expiration is, that you cannot be really sure that who caches it where. There can be a lonely router somewhere between your cell phone and the actual server that decided to forcefully hang on to that resource. What if you need to do an emergency patch? Do you need to wait until the very last cache somewhere expires?</p><h3 id="around-the-cache">Around the cache</h3><p>Before we go to the answer, I&#39;d like to share a good mindset: Always seek for better practices.</p><p>This is why I like <a href="http://yeoman.io/">Yeoman</a>. It is basically all the greatest minds working together to bring the best practices for everyone, easily.</p><p>For example the <a href="https://github.com/yeoman/generator-webapp">webapp generator</a> is pure genius: It sets up all the shiny toys for you with zero configuration: Babel, SASS, Bower, Mocha, Grunt, Livereload, etc. etc.</p><p>I happened to remember that the webapp generator used grunt-usemin plugin that in turn uses <a href="https://github.com/yeoman/grunt-filerev">grunt-filerev</a> plugin to create an extra hash to filenames, which gets dynamically injected to the code.</p><blockquote><p>[The plugin] will revision your files based on its contents. You should then set the files to expire far into the future for better caching and it will only update when it changes.</p></blockquote><p>What this means in practice is that the filename <code>style.css</code> will be renamed to <code>style.59bcc3ad.css</code>. The <code>59bcc3ad</code> is the compiled hash of that file, which means that the filename changes only if the file&#39;s content changes.</p><p>This pretty much gets us around the cache, but also leverages the content caching whenever it is possible. So a perfect solution for us!</p><h3 id="setting-cache-headers-in-apache">Setting cache headers in Apache</h3><p>After the hashed filenames, setting cache headers for the files was quite trivial task. Just throw <code>.htaccess</code> file to the folder and we&#39;re done!</p><pre><code><span class="hljs-section">&lt;IfModule mod_expires.c&gt;</span>
    <span class="hljs-attribute">ExpiresActive</span> <span class="hljs-literal">On</span>
    <span class="hljs-attribute">ExpiresDefault</span> <span class="hljs-string">"access plus 1 month"</span>
<span class="hljs-section">&lt;/IfModule&gt;</span>
</code></pre><p>After deploying the changes, the feeling was unbearable: Would this be the first time I&#39;d get to brag with a <em>100/100</em> site?</p><blockquote><p>Mobile: <em>100/100</em>, Desktop: <em>100/100</em></p></blockquote><p>Success! Finally! My first personal <em>100/100</em> site was built!</p><p><a href="https://twitter.com/intent/tweet?text=%22How%20to%20get%20100/100%20in%20Google%20PageSpeed%20Insights%22%20by%20@luotojesse%20https://thejunkland.com/blog/howtoget.html" class="twittershare" target="_blank">Tweet</a></p></article><footer><p>This site was made with &#9825; by Jesse Luoto.</p><p>Header font is <a href="https://www.google.com/fonts/specimen/Oswald">Oswald Regular</a> from Google Fonts</p><nav><a href="/index.html">Blog</a> <a href="/about.html">About</a></nav></footer><script src="https://cdn.jsdelivr.net/ga-lite/latest/ga-lite.min.js" async></script><script src="/scripts.92d7e677.js" async></script></body></html>